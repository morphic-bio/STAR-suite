#include "solo/CbCorrector.h"
#include "SequenceFuns.h"
#include <algorithm>
#include <cstring>
#include <functional>

CbCorrector::CbCorrector(const std::vector<std::string> &whitelist, int maxHamming)
    : maxHamming_(maxHamming) {
    
    // Store whitelist
    whitelist_ = whitelist;
    
    // Determine CB length (assume all CBs have same length)
    if (!whitelist_.empty()) {
        cbLength_ = whitelist_[0].length();
    } else {
        cbLength_ = 0;
    }
    
    // Build exact lookup map using packed keys
    for (size_t i = 0; i < whitelist_.size(); i++) {
        PackedCB packed;
        if (encodeCB(whitelist_[i], packed)) {
            exactMap_[packed.key] = static_cast<uint32_t>(i);
        }
    }
    
    // Precompute 1-hamming variants if maxHamming >= 1
    if (maxHamming_ >= 1) {
        for (size_t i = 0; i < whitelist_.size(); i++) {
            PackedCB packed;
            if (!encodeCB(whitelist_[i], packed)) {
                continue; // Skip invalid CB
            }
            
            std::vector<PackedCB> variants;
            generateVariants(packed, variants, cbLength_);
            
            for (const PackedCB &variant : variants) {
                // Check if this variant was already generated by another WL entry
                auto it = variantMap_.find(variant.key);
                if (it == variantMap_.end()) {
                    // First time seeing this variant - store WL index (convert to 1-based)
                    variantMap_[variant.key] = to1Based(static_cast<uint32_t>(i));
                } else {
                    // Collision: multiple WL entries generate this variant
                    if (it->second != 0) {
                        // Move existing entry to ambiguous map
                        uint32_t existingIdx = it->second;
                        ambiguousVariants_[variant.key].push_back(existingIdx - 1); // Convert back to 0-based
                        ambiguousVariants_[variant.key].push_back(static_cast<uint32_t>(i));
                        variantMap_[variant.key] = 0; // Mark as ambiguous
                    } else {
                        // Already ambiguous, just add this index
                        ambiguousVariants_[variant.key].push_back(static_cast<uint32_t>(i));
                    }
                }
            }
        }
    }
}

// Encode CB string to packed key + N mask
bool CbCorrector::encodeCB(const std::string &cb, PackedCB &packed) const {
    packed.key = 0;
    packed.nMask = 0;
    
    if (cb.length() > 16) {
        return false; // CB too long for 32-bit packing
    }
    
    for (size_t i = 0; i < cb.length(); i++) {
        char base = cb[i];
        uint32_t code = 0;
        
        if (base == 'A' || base == 'a') code = 0;
        else if (base == 'C' || base == 'c') code = 1;
        else if (base == 'G' || base == 'g') code = 2;
        else if (base == 'T' || base == 't') code = 3;
        else if (base == 'N' || base == 'n') {
            // Mark N position in mask
            packed.nMask |= (1u << i);
            code = 0; // Use A as placeholder
        } else {
            return false; // Invalid base
        }
        
        // Pack: shift left 2 bits, add new base
        packed.key = (packed.key << 2) | code;
    }
    
    return true;
}

// Decode packed key back to CB string
std::string CbCorrector::decodeCB(const PackedCB &packed, size_t cbLength) const {
    const char bases[] = "ACGT";
    std::string cb(cbLength, 'N');
    
    uint32_t key = packed.key;
    for (size_t i = 0; i < cbLength; i++) {
        size_t pos = cbLength - 1 - i; // Decode from right to left
        uint32_t code = key & 3;
        key >>= 2;
        
        // Check if this position has N
        if (packed.nMask & (1u << pos)) {
            cb[pos] = 'N';
        } else {
            cb[pos] = bases[code];
        }
    }
    
    return cb;
}

// Generate all 1-hamming variants of a packed CB
void CbCorrector::generateVariants(const PackedCB &packed, std::vector<PackedCB> &variants, size_t cbLength) const {
    variants.clear();
    
    // For each position, try replacing with the other 3 nucleotides
    for (size_t pos = 0; pos < cbLength; pos++) {
        // Extract current base at this position
        uint32_t shift = 2 * (cbLength - 1 - pos);
        uint32_t currentBase = (packed.key >> shift) & 3;
        
        // Try the other 3 bases
        for (uint32_t altBase = 0; altBase < 4; altBase++) {
            if (altBase == currentBase) continue;
            
            PackedCB variant = packed;
            // Clear current base and set new base
            variant.key &= ~(3u << shift);
            variant.key |= (altBase << shift);
            variants.push_back(variant);
        }
    }
}

bool CbCorrector::hasN(const std::string &cb) const {
    for (char c : cb) {
        if (c == 'N' || c == 'n') {
            return true;
        }
    }
    return false;
}

bool CbCorrector::expandN(const PackedCB &packed, size_t cbLength, PackedCB &corrected, int &hammingDist, 
                           std::vector<PackedCB> &ambiguousSeqs) const {
    corrected.key = 0;
    corrected.nMask = 0;
    hammingDist = 255;
    ambiguousSeqs.clear();
    
    if (!packed.hasN()) {
        return false; // No Ns to expand
    }
    
    // Extract N positions from mask
    std::vector<size_t> nPositions;
    for (size_t i = 0; i < cbLength; i++) {
        if (packed.nMask & (1u << i)) {
            nPositions.push_back(i);
        }
    }
    
    // Iterative expansion: use flat array like process_features
    // Preallocate array for expanded packed keys
    const size_t MAX_EXPANDED_SEQS = 256; // Reasonable limit: 4^4 = 256
    PackedCB corrected_keys[MAX_EXPANDED_SEQS];
    size_t corrected_seq_count = 0;
    
    // Copy original packed CB into first slot
    corrected_keys[0] = packed;
    corrected_seq_count = 1;
    
    // For each N position, expand all current sequences by replacing N with A/C/G/T
    for (size_t nPos : nPositions) {
        size_t current_count = corrected_seq_count;
        uint32_t shift = 2 * (cbLength - 1 - nPos);
        
        // For each existing sequence, create 4 new sequences (one for each base)
        for (size_t i = 0; i < current_count; i++) {
            PackedCB original = corrected_keys[i];
            
            // Create 4 sequences: one for each base (A, C, G, T)
            for (uint32_t baseIdx = 0; baseIdx < 4; baseIdx++) {
                if (baseIdx == 0) {
                    // First base (A): overwrite current slot
                    corrected_keys[i].key &= ~(3u << shift);
                    corrected_keys[i].key |= (baseIdx << shift);
                    corrected_keys[i].nMask &= ~(1u << nPos); // Clear N bit
                } else {
                    // Additional bases (C, G, T): create new slots
                    if (corrected_seq_count >= MAX_EXPANDED_SEQS) {
                        return false; // Too many sequences
                    }
                    
                    // Copy original packed CB to new slot, then replace N
                    corrected_keys[corrected_seq_count] = original;
                    corrected_keys[corrected_seq_count].key &= ~(3u << shift);
                    corrected_keys[corrected_seq_count].key |= (baseIdx << shift);
                    corrected_keys[corrected_seq_count].nMask &= ~(1u << nPos); // Clear N bit
                    corrected_seq_count++;
                }
            }
        }
    }
    
    // Now check each expanded sequence against whitelist using packed keys
    // Strategy: 
    // 1. First pass: check ALL expanded sequences for exact matches (0 hash)
    // 2. Second pass: ONLY if no exact matches, check ALL for 1-hamming variants (1 hash)
    // 3. Do NOT early return - check all sequences first
    // 4. Track ambiguous hits (up to 5)
    const size_t MAX_AMBIGUOUS_HITS = 5;
    std::vector<std::pair<PackedCB, int>> bestHits; // (packedCB, hammingDist)
    
    // First pass: check ALL expanded sequences for exact matches (0 hash)
    std::vector<PackedCB> exactMatches;
    for (size_t i = 0; i < corrected_seq_count; i++) {
        const PackedCB &candidate = corrected_keys[i];
        auto exactIt = exactMap_.find(candidate.key);
        if (exactIt != exactMap_.end()) {
            exactMatches.push_back(candidate);
        }
    }
    
    // If we have exact matches, use those (don't check 1-hamming hash)
    if (!exactMatches.empty()) {
        if (exactMatches.size() == 1) {
            // Exactly one exact match - return it
            corrected = exactMatches[0];
            hammingDist = 0;
            return true;
        } else {
            // Multiple exact matches - ambiguous
            for (const PackedCB &seq : exactMatches) {
                if (bestHits.size() < MAX_AMBIGUOUS_HITS) {
                    bestHits.push_back(std::make_pair(seq, 0));
                }
            }
            // Return ambiguous result
            corrected = bestHits[0].first;
            hammingDist = 0;
            ambiguousSeqs.clear();
            for (const auto &hit : bestHits) {
                if (ambiguousSeqs.size() < MAX_AMBIGUOUS_HITS) {
                    ambiguousSeqs.push_back(hit.first);
                }
            }
            return false; // Ambiguous
        }
    }
    
    // Second pass: ONLY if no exact matches, check ALL for 1-hamming variants (1 hash)
    if (maxHamming_ >= 1) {
        std::vector<PackedCB> variantMatches;
        std::vector<uint32_t> ambiguousIndices; // Collect all ambiguous indices
        
        for (size_t i = 0; i < corrected_seq_count; i++) {
            const PackedCB &candidate = corrected_keys[i];
            auto variantIt = variantMap_.find(candidate.key);
            if (variantIt != variantMap_.end()) {
                if (variantIt->second == 0) {
                    // Ambiguous variant - look up ambiguous hash
                    auto ambIt = ambiguousVariants_.find(candidate.key);
                    if (ambIt != ambiguousVariants_.end()) {
                        // Collect all ambiguous indices
                        for (uint32_t idx : ambIt->second) {
                            ambiguousIndices.push_back(idx);
                        }
                    }
                } else {
                    // Non-ambiguous variant - track for uniqueness check
                    variantMatches.push_back(candidate);
                }
            }
        }
        
        // Count total ambiguous matches
        size_t totalAmbiguous = ambiguousIndices.size() + variantMatches.size();
        
        // If more than 5 ambiguous matches, return no match
        if (totalAmbiguous > 5) {
            return false; // No match
        }
        
        if (variantMatches.size() == 1 && ambiguousIndices.empty()) {
            // Exactly one non-ambiguous variant - return it
            corrected = variantMatches[0];
            hammingDist = 1;
            return true;
        } else if (totalAmbiguous > 0) {
            // Ambiguous: collect sequences for return
            // First add non-ambiguous variants
            for (const PackedCB &seq : variantMatches) {
                if (bestHits.size() < MAX_AMBIGUOUS_HITS) {
                    bestHits.push_back(std::make_pair(seq, 1));
                }
            }
            // Then add ambiguous variants (we already have indices, but need sequences)
            // For ambiguous variants, we track the sequences that generated them
            for (size_t i = 0; i < corrected_seq_count && bestHits.size() < MAX_AMBIGUOUS_HITS; i++) {
                const PackedCB &candidate = corrected_keys[i];
                auto variantIt = variantMap_.find(candidate.key);
                if (variantIt != variantMap_.end() && variantIt->second == 0) {
                    bestHits.push_back(std::make_pair(candidate, 1));
                }
            }
            // Return ambiguous result
            corrected = bestHits[0].first;
            hammingDist = 1;
            ambiguousSeqs.clear();
            for (const auto &hit : bestHits) {
                if (ambiguousSeqs.size() < MAX_AMBIGUOUS_HITS) {
                    ambiguousSeqs.push_back(hit.first);
                }
            }
            return false; // Ambiguous
        }
    }
    
    // No match found
    return false;
}

CbMatch CbCorrector::correct(const std::string &cb) const {
    CbMatch result;
    
    // Normalize input: convert to uppercase
    std::string normalized = cb;
    std::transform(normalized.begin(), normalized.end(), normalized.begin(), ::toupper);
    
    // Encode to packed key
    PackedCB packed;
    if (!encodeCB(normalized, packed)) {
        return result; // Invalid CB, no match
    }
    
    // Check for Ns
    if (packed.hasN()) {
        // Try N expansion using packed keys
        PackedCB expanded;
        int hammingDist;
        std::vector<PackedCB> ambiguousSeqs;
        if (expandN(packed, cbLength_, expanded, hammingDist, ambiguousSeqs)) {
            // Successfully expanded Ns to unique match (early return from expandN)
            // Look up the whitelist index using packed key
            if (hammingDist == 0) {
                // Exact match
                auto exactIt = exactMap_.find(expanded.key);
                if (exactIt != exactMap_.end()) {
                    result.whitelistIdx = to1Based(exactIt->second);
                    result.hammingDist = 0;
                    result.ambiguous = false;
                    return result;
                }
            } else if (hammingDist == 1) {
                // 1-hamming variant
                auto variantIt = variantMap_.find(expanded.key);
                if (variantIt != variantMap_.end() && variantIt->second != 0) {
                    result.whitelistIdx = variantIt->second;
                    result.hammingDist = 1;
                    result.ambiguous = false;
                    return result;
                }
            }
        } else {
            // expandN returned false - could be ambiguous or no match
            // Check if we got ambiguous sequences
            if (!ambiguousSeqs.empty()) {
                // Collect all whitelist indices for ambiguous sequences
                std::vector<uint32_t> allAmbiguousIndices;
                
                for (const PackedCB &seq : ambiguousSeqs) {
                    // Check exact match first
                    auto exactIt = exactMap_.find(seq.key);
                    if (exactIt != exactMap_.end()) {
                        allAmbiguousIndices.push_back(exactIt->second);
                        continue;
                    }
                    
                    // Check variant match
                    if (maxHamming_ >= 1 && hammingDist == 1) {
                        auto variantIt = variantMap_.find(seq.key);
                        if (variantIt != variantMap_.end()) {
                            if (variantIt->second == 0) {
                                // Get from ambiguousVariants_ map
                                auto ambIt = ambiguousVariants_.find(seq.key);
                                if (ambIt != ambiguousVariants_.end()) {
                                    for (uint32_t idx : ambIt->second) {
                                        allAmbiguousIndices.push_back(idx);
                                    }
                                }
                            } else {
                                allAmbiguousIndices.push_back(variantIt->second - 1); // Convert 1-based to 0-based
                            }
                        }
                    }
                }
                
                // If more than 5 ambiguous matches, return no match
                if (allAmbiguousIndices.size() > 5) {
                    return result; // No match
                }
                
                // Return ambiguous result (up to 5 indices)
                if (!allAmbiguousIndices.empty()) {
                    result.ambiguous = true;
                    result.hammingDist = static_cast<uint8_t>(hammingDist);
                    for (uint32_t idx : allAmbiguousIndices) {
                        result.ambiguousIdx.push_back(to1Based(idx));
                    }
                    return result;
                }
            }
        }
        // If expansion failed or no match, result stays as no match
        return result;
    }
    
    // Check exact match first using packed key
    auto exactIt = exactMap_.find(packed.key);
    if (exactIt != exactMap_.end()) {
        result.whitelistIdx = to1Based(exactIt->second);
        result.hammingDist = 0;
        result.ambiguous = false;
        return result;
    }
    
    // If maxHamming is 0, only exact matches allowed
    if (maxHamming_ < 1) {
        return result; // No match
    }
    
    // Check 1-hamming variants using packed key
    auto variantIt = variantMap_.find(packed.key);
    if (variantIt != variantMap_.end()) {
        if (variantIt->second == 0) {
            // Ambiguous: multiple WL entries match - look up ambiguous hash
            auto ambIt = ambiguousVariants_.find(packed.key);
            if (ambIt != ambiguousVariants_.end()) {
                // If more than 5 ambiguous matches, return no match
                if (ambIt->second.size() > 5) {
                    return result; // No match
                }
                
                // Return ambiguous result (up to 5 indices)
                result.ambiguous = true;
                result.hammingDist = 1;
                for (uint32_t idx : ambIt->second) {
                    result.ambiguousIdx.push_back(to1Based(idx));
                }
            }
        } else {
            // Unique 1-hamming match
            result.whitelistIdx = variantIt->second;
            result.hammingDist = 1;
            result.ambiguous = false;
        }
        return result;
    }
    
    // No match found
    return result;
}

// Decode packed key to CB string (public helper)
std::string CbCorrector::decodePackedKey(uint32_t packedKey, size_t cbLength) const {
    const char bases[] = "ACGT";
    std::string cb(cbLength, 'N');
    
    uint32_t key = packedKey;
    for (size_t i = 0; i < cbLength; i++) {
        size_t pos = cbLength - 1 - i; // Decode from right to left
        uint32_t code = key & 3;
        key >>= 2;
        cb[pos] = bases[code];
    }
    
    return cb;
}


