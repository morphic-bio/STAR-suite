# GC Bias Integration Handoff Summary

## Overview
This document summarizes the work completed to integrate GC bias correction into the STAR-Flex EM/VB quantification pipeline, matching Salmon's `--gcBias` functionality.

## Completed Components

### 1. Core GC Bias Infrastructure

#### `source/libem/gc_bias.h` and `source/libem/gc_bias.cpp`
- **GCFragModel class**: Handles GC distribution storage and manipulation
  - 101 GC bins (0-100% GC)
  - Log-space and linear-space accumulation (`inc()`, `incLinear()`)
  - Normalization to probabilities
  - Bias ratio computation (`computeBiasRatio()`)
  - File I/O (TSV format: `gc_bin <tab> probability`)

#### `source/libem/alignment_model.h` and `source/libem/alignment_model.cpp`
- **gcFrac() method**: Added to `TranscriptSequence` class
  - Computes GC percentage of a fragment given start/end positions
  - Uses SAM 4-bit encoding (C=2, G=4) to count GC bases
  - Returns integer percentage (0-100)

#### `source/libem/effective_length.h` and `source/libem/effective_length.cpp`
- **EffectiveLengthCalculator class**: Computes GC-corrected effective lengths
  - Loads fragment length distribution (FLD) from TSV
  - Loads GC bias ratios
  - Computes effective length per transcript using:
    - FLD-based weighting (CDF-based, with quantile bounds)
    - GC bias correction per fragment
  - Supports quantile-based FLD trimming (default: 0.5% and 99.5%)

### 2. EC Filter CLI Integration

#### `tools/ec_filter_test/ec_filter_cli.cpp`
- **GC Bias Collection**: Added `--gc-bias` option
  - Collects observed GC distribution from aligned fragments
  - Only processes properly paired fragments
  - Weights observations by alignment probability (log space)
  - Requires `--transcripts` and `--observed-gc-out` options
  - Outputs observed GC distribution to TSV file

**Key Changes:**
- Added `GCFragModel* observed_gc` initialization
- Modified `finalize_read_group` lambda to collect GC from fragments
- Ensures BAM data is populated when GC bias is enabled (even without error model)
- Writes observed GC distribution at end of processing

**Current Issue**: GC collection runs but collects all zeros. Likely causes:
- BAM data population logic may not be working correctly when only GC bias is enabled
- Fragment pairing detection may be failing
- Fragment boundary calculation may have issues

### 3. Standalone Tools

#### `tools/compute_gc_bias/compute_gc_bias.cpp`
- **Purpose**: Combines expected GC, observed GC, and FLD to compute effective lengths
- **Inputs**:
  - `--expected-gc`: Expected GC distribution (TSV)
  - `--observed-gc`: Observed GC distribution (TSV)
  - `--fld`: Fragment length distribution (TSV)
  - `--transcriptome`: Transcriptome FASTA
- **Output**: Effective lengths TSV (`transcript_id <tab> eff_length`)

#### `tools/compute_expected_gc/compute_expected_gc.c` (Previously completed)
- Computes expected GC distribution from transcriptome and FLD
- Supports CDF-based weighting and quantile bounds
- Outputs TSV format

#### `tools/sample_fld/sample_fld.c` (Previously completed)
- Samples fragment length distribution from BAM file
- Outputs TSV format (`length <tab> count <tab> probability`)

### 4. EM/VB Quantification Integration

#### `tools/em_quant/em_quant.cpp`
- **Added `--effective-lengths` option**: Loads GC-corrected effective lengths
- Overrides effective lengths from quant.sf file if provided
- Uses `load_effective_lengths()` function from `ec_loader.cpp`

#### `source/libem/ec_loader.h` and `source/libem/ec_loader.cpp`
- **Added `load_effective_lengths()` function**: Loads effective lengths from simple TSV
  - Format: `transcript_index <tab> eff_length`
  - Overrides existing effective lengths in `TranscriptState`

### 5. Parity Test Infrastructure

#### `tools/compute_expected_gc/test_gc_bias_parity.sh`
- End-to-end parity test script comparing our pipeline with Salmon's `--gcBias`
- Steps:
  1. Run Salmon with `--gcBias`
  2. Sample FLD from BAM
  3. Compute expected GC distribution
  4. Collect observed GC from alignments
  5. Compute GC-corrected effective lengths
  6. Run VB quantification with effective lengths
  7. Compare results (effective lengths, TPM, NumReads)

**Comparison Script**: `compare_quant.py` (generated by test script)
- Computes correlation and RMSE for effective lengths, TPM, and NumReads
- Provides pass/fail assessment based on tolerances

## File Locations

### Core Library Files
- `source/libem/gc_bias.h` / `gc_bias.cpp` - GCFragModel class
- `source/libem/effective_length.h` / `effective_length.cpp` - EffectiveLengthCalculator
- `source/libem/alignment_model.h` / `alignment_model.cpp` - gcFrac() method
- `source/libem/ec_loader.h` / `ec_loader.cpp` - load_effective_lengths()

### Tools
- `tools/ec_filter_test/ec_filter_cli.cpp` - GC collection integration
- `tools/compute_gc_bias/compute_gc_bias.cpp` - Effective length computation tool
- `tools/em_quant/em_quant.cpp` - Effective lengths option
- `tools/compute_expected_gc/compute_expected_gc.c` - Expected GC computation
- `tools/sample_fld/sample_fld.c` - FLD sampling

### Test Infrastructure
- `tools/compute_expected_gc/test_gc_bias_parity.sh` - End-to-end parity test

### Build Files
- `source/libem/Makefile` - Added `effective_length.o` to `LIBEM_OBJECTS`
- `tools/compute_gc_bias/Makefile` - Build file for compute_gc_bias tool

## Current Status

### ✅ Completed
1. All core classes and methods implemented
2. All tools compile successfully
3. Integration points added to CLI tools
4. Parity test script created
5. **GC bias bugs fixed (Dec 19, 2025)**

### ✅ Fixed Issues (Dec 19, 2025)

#### Bug 1: Missing Brace in finalize_read_group Lambda
**Symptom**: EC processing code (`read_alignments.push_back(...)`) was inside the gc_bias if-block.
**Fix**: Added missing closing brace to properly close the gc_bias collection block.
**Location**: `ec_filter_cli.cpp` lines ~999-1000

#### Bug 2: Transcriptome Not Reordered for GC-Only Mode
**Symptom**: When only `--gc-bias` was enabled (without error model), transcriptome wasn't reordered to match BAM header.
**Fix**: Changed `if (alignment_model)` to `if (alignment_model || gc_bias_enabled)` for transcriptome reordering.
**Location**: `ec_filter_cli.cpp` line ~804

#### Bug 3: BAM Data Not Populated for GC Bias in Multiple Code Paths
**Symptom**: Several code paths only populated BAM data for error model, not GC bias.
**Fix**: Changed `if (alignment_model)` to `if (alignment_model || gc_bias_enabled)` in 6 locations:
- Line ~1083: Buffered mode single mate
- Line ~1209: Buffered mode single-end
- Line ~1370: Streaming mode discordant pairs
- Line ~1410: Streaming mode proper pairs
- Line ~1441: Streaming mode orphan mate

## Next Steps

### Verify GC Collection Works
1. **Run GC Bias Test**:
   - Log when observations are added to GCFragModel

2. **Verify BAM Data Flow**:
   - Ensure BAM records are cloned when `gc_bias_enabled` is true
   - Check that paired-end reads have both `read1` and `read2` populated
   - Verify BAM records remain valid until GC collection

3. **Test Fragment Processing**:
   - Run on a small test BAM with known fragments
   - Manually verify fragment boundaries match expected values
   - Check GC percentages match manual calculation

### After GC Collection Works
1. **Run Parity Test**: Execute `test_gc_bias_parity.sh` and compare with Salmon
2. **Debug Differences**: If parity test fails, investigate:
   - Effective length calculation differences
   - GC bias ratio computation differences
   - Quantification differences

### Future Enhancements
1. **2D Context Conditioning**: Implement 5bp upstream/downstream context GC (currently 1D only)
2. **Fragment Sampling**: Match Salmon's fragment sampling approach if needed
3. **Transcript Weighting**: Implement Salmon's transcript-level weighting if required

## Testing

### Manual Test Commands

```bash
# 1. Sample FLD
tools/sample_fld/sample_fld --bam <bam_file> --output fld.tsv

# 2. Compute expected GC
tools/compute_expected_gc/compute_expected_gc \
    --transcriptome <transcriptome.fasta> \
    --fld fld.tsv \
    --output expected_gc.tsv

# 3. Collect observed GC (currently returns zeros - needs debugging)
tools/ec_filter_test/ec_filter_cli \
    --input <bam_file> \
    --transcripts <transcriptome.fasta> \
    --gc-bias \
    --expected-gc expected_gc.tsv \
    --observed-gc-out observed_gc.tsv \
    --output eq_classes.txt

# 4. Compute effective lengths
tools/compute_gc_bias/compute_gc_bias \
    --expected-gc expected_gc.tsv \
    --observed-gc observed_gc.tsv \
    --fld fld.tsv \
    --transcriptome <transcriptome.fasta> \
    --output effective_lengths.tsv

# 5. Run quantification with GC-corrected effective lengths
tools/em_quant/em_quant \
    --ec eq_classes.txt \
    --effective-lengths effective_lengths.tsv \
    --vb \
    --output quant.sf
```

### End-to-End Parity Test

```bash
tools/compute_expected_gc/test_gc_bias_parity.sh \
    <test_dir> \
    <bam_file> \
    <transcriptome.fasta>
```

## Key Design Decisions

1. **101 GC Bins**: Matches our implementation (Salmon uses 25 bins, but we use 101 for finer granularity)
2. **CDF-based Weighting**: Matches Salmon's approach for FLD weighting
3. **Quantile Bounds**: Uses 0.5% and 99.5% quantiles for FLD trimming (matching Salmon)
4. **Log-space Accumulation**: GC observations accumulated in log space to match Salmon
5. **Alignment Weighting**: GC observations weighted by alignment probability (matching Salmon)

## Dependencies

- htslib (for BAM parsing)
- Standard C++11 libraries
- Python3 with pandas/numpy (for parity test comparison)

## Related Documentation

- Previous harmonization work: `tools/compute_expected_gc/HARMONIZATION_TEST_RESULTS.md`
- Error model parity: `tools/ec_filter_test/SALMON_INSTRUMENTATION_COMPLETE.md`

